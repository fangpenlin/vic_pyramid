from __future__ import unicode_literals
import os
import unittest
import tempfile
import textwrap
import shutil

import mock
from pyramid.httpexceptions import HTTPBadRequest

from {{package}}.utils import generate_random_code
from {{package}}.utils import check_csrf_token
from {{package}}.utils import load_app_cfg


class TestUtils(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()

    def tearDown(self):
        shutil.rmtree(self.temp_dir)
        
    def test_check_csrf_token(self):
        session = mock.Mock()
        session.get_csrf_token.return_value = 'MOCK_CSRF_TOKEN'
        request = mock.Mock(
            session=session,
            params=dict(csrf_token='MOCK_CSRF_TOKEN')
        )

        check_csrf_token(request)
        session.get_csrf_token.assert_called_once_with()

        request = mock.Mock(
            session=session,
            params=dict(csrf_token='BAD_TOKEN')
        )
        with self.assertRaises(HTTPBadRequest):
            check_csrf_token(request)

    def test_generate_random_code(self):
        times = 1000
        codes = [generate_random_code() for _ in range(times)]
        self.assertEqual(len(set(codes)), times)

    def test_load_app_cfg(self):
        # make sure the configuration is loaded correctly
        cfg = load_app_cfg()
        self.assertTrue(cfg)

        app_cfg_path = os.path.join(self.temp_dir, 'appcfg.yaml')
        with open(app_cfg_path, 'wt') as temp:
            temp.write(textwrap.dedent("""\
            ---
            mock_key: mock_value
            ...
            """))

        os.environ['APP_CFG_PATH'] = app_cfg_path
        cfg = load_app_cfg()
        self.assertEqual(cfg, dict(mock_key='mock_value'))
